# C语言内存模型  
> + + 具体含义(功能）
>   + 调用方式
>   + 应用场景
+ 程序代码区 (code)
    + 用于存储需要执行的程序代码
    + 编写程序后进行编译
    + 代码执行
+ 常量区 (constant)
    + 用于存储常量
    + const定义常量
    + 编写程序时定义常量
+ 全局数据区/静态区 (global data)
    + 用于存储全局变量和static静态变量
    + 在函数外定义变量，或定义静态变量
    + 编写程序时定义全局变量
+ 堆区 (heap)
    + 用于存储动态分配的内存
    + malloc函数申请内存，free函数释放内存
    + 创建链表
+ 动态链接库
    + 用于存储预先编译好的可执行代码集合
    + 可以通过编译时使用-shared -fPIC参数产生动态库动态库生成之后，就可以使用-ltest -L. 的方式使用该动态库
    + 避免了每个应用程序都包含相同功能代码的冗余
+ 栈区 (stack)
    + 用于存储函数调用的所有信息和所有局部变量
    + 由编译器自动分配释放
    + 函数的调用    

1.栈需要存储的元素容量大于其本身的容量  
2.栈区由编译器自动分配释放，堆区需要手动申请、释放内存  
3.只读：程序代码区，常量区（代码执行时），动态链接库  
可读写：全局数据区，堆区，栈区  
4.先声明头文件stdlib.h  
malloc函数：malloc(sizeof(定义类型））返回所申请内存（大小又定义类型决定）的void类型指针（一般需要强制转换）  
free函数：free(指针)释放指针所指地址的内存  
针对堆区进行操作  
5.确保系统中的所有程序都能够访问所需的内存，并且不会发生 内存冲突 或内存泄漏等问题  
# 内存模型的应用  
constValue：常量区，因为使用了const定义  
constString：常量区，因为使用了const定义  
globalVar：全局数据区，因为是在函数外的简单int定义  
staticVar：全局数据区/静态区，因为使用了static定义  
localVar：栈区，因为是在函数内的简单int定义  
ptr：堆区，因为ptr指针指向的地址是堆区  
localVarMain：栈区，，因为是在函数内的简单int定义  
# 浅谈Cache  
1.冯诺依曼体系结构：计算机由运算器、存储器、控制器、输入设备、输出设备组成  
现代计算机的组织结构：在冯诺依曼体系结构的基础上，将运算器和控制器结合到一起组成CPU  
前者以运算器为中心，后者以存储器为中心  
2.主存储器工作：首先 CPU 中的控制器发出读命令等控制信号，通过地址总线将存储单元的地址从 MAR 传输到主存储器。主存储器根据地址找到相应的存储单元，将存储单元中的数据通过数据总线传输到 MDR，再由 MDR 传输到 CPU 内部进行处理。在写入操作时，CPU 将数据加载到 MDR 中，将要写入数据的内存地址加载到 MAR 中，然后发出写入数据的指令，将 MDR 中的数据写入到 MAR 指示的内存位置  
3.局部性原理包括 ①时间局部性：如果一个数据被访问过一次，那么在不久的将来很可能再次被访问 ②空间局部性：如果一个数据被访问过，那么它附近的数据也很可能会被访问 ③顺序局部性：在典型程序中，除转移类指令外，大部分指令是顺序进行的  
4.缓存根据局部性原理，使程序在短时间内访问的数据和指令往往集中在一个小范围内，从而提高访问速度

